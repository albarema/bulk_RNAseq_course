<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Bulk RNAseq data analysis - Count normalization with DESeq2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@id": "https://hds-sandbox.github.io/bulk_RNAseq_course/",
      "@type": "LearningResource",
      "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
      "description": "This workshop includes a tutorial on how to approach RNAseq data, starting from your sequencing reads (fastq files). Thus, the workshop only briefly touches upon laboratory protocols, library preparation, and experimental design of RNA sequencing experiments, mainly for the purpose of outlining considerations in the downstream bioinformatic analysis. This workshop is based on the materials developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC), a collection of modified tutorials from the DESeq2, R language vignettes and the nf-core rnaseq pipeline.",
      "keywords": [
        "bioinformatics, RNAseq, bulk, NGS"
      ],
      "learningResourceType": [
        "e-learning"
      ],
      "license": [
        {
          "@id": "https://creativecommons.org/licenses/by-sa/4.0/legalcode",
          "@type": "CreativeWork"
        }
      ],
      "mentions": [
        {
          "@id": "10.5281/zenodo.8046218",
          "@type": "Thing"
        },
        {
          "@id": "https://zenodo.org/record/7956067",
          "@type": "Thing"
        }
      ],
      "name": "Introduction to bulk RNAseq analysis workshop",
      "educationalLevel": "Beginner",
      "audience": "Researchers, PhDs, Postdocs, MSc"
    }
    </script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../develop/img/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Bulk RNAseq data analysis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.qmd"> 
<span class="menu-text">Introduction</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.qmd"> 
<span class="menu-text">Experimental planning</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/hds-sandbox"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#normalization" id="toc-normalization" class="nav-link active" data-scroll-target="#normalization">Normalization</a>
  <ul class="collapse">
  <li><a href="#common-normalization-methods" id="toc-common-normalization-methods" class="nav-link" data-scroll-target="#common-normalization-methods">Common normalization methods</a></li>
  <li><a href="#rpkmfpkm-not-recommended" id="toc-rpkmfpkm-not-recommended" class="nav-link" data-scroll-target="#rpkmfpkm-not-recommended">RPKM/FPKM (not recommended)</a></li>
  <li><a href="#deseq2-normalized-counts-median-of-ratios-method" id="toc-deseq2-normalized-counts-median-of-ratios-method" class="nav-link" data-scroll-target="#deseq2-normalized-counts-median-of-ratios-method">DESeq2-normalized counts: Median of ratios method</a>
  <ul class="collapse">
  <li><a href="#step-1-creates-a-pseudo-reference-sample-row-wise-geometric-mean" id="toc-step-1-creates-a-pseudo-reference-sample-row-wise-geometric-mean" class="nav-link" data-scroll-target="#step-1-creates-a-pseudo-reference-sample-row-wise-geometric-mean">Step 1: creates a pseudo-reference sample (row-wise geometric mean)</a></li>
  <li><a href="#step-2-calculates-ratio-of-each-sample-to-the-reference" id="toc-step-2-calculates-ratio-of-each-sample-to-the-reference" class="nav-link" data-scroll-target="#step-2-calculates-ratio-of-each-sample-to-the-reference">Step 2: calculates ratio of each sample to the reference</a></li>
  <li><a href="#step-3-calculate-the-normalization-factor-for-each-sample-size-factor" id="toc-step-3-calculate-the-normalization-factor-for-each-sample-size-factor" class="nav-link" data-scroll-target="#step-3-calculate-the-normalization-factor-for-each-sample-size-factor">Step 3: calculate the normalization factor for each sample (size factor)</a></li>
  <li><a href="#step-4-calculate-the-normalized-count-values-using-the-normalization-factor" id="toc-step-4-calculate-the-normalized-count-values-using-the-normalization-factor" class="nav-link" data-scroll-target="#step-4-calculate-the-normalized-count-values-using-the-normalization-factor">Step 4: calculate the normalized count values using the normalization factor</a></li>
  </ul></li>
  <li><a href="#count-normalization-of-the-vampirium-dataset-using-deseq2" id="toc-count-normalization-of-the-vampirium-dataset-using-deseq2" class="nav-link" data-scroll-target="#count-normalization-of-the-vampirium-dataset-using-deseq2">Count normalization of the Vampirium dataset using DESeq2</a>
  <ul class="collapse">
  <li><a href="#match-the-metadata-and-counts-data" id="toc-match-the-metadata-and-counts-data" class="nav-link" data-scroll-target="#match-the-metadata-and-counts-data">1. Match the metadata and counts data</a></li>
  <li><a href="#create-deseq2-object" id="toc-create-deseq2-object" class="nav-link" data-scroll-target="#create-deseq2-object">2. Create DESEq2 object</a></li>
  <li><a href="#generate-the-normalized-counts" id="toc-generate-the-normalized-counts" class="nav-link" data-scroll-target="#generate-the-normalized-counts">3. Generate the normalized counts</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Count normalization with DESeq2</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="normalization" class="level1">
<h1>Normalization</h1>
<p><strong>Last updated:</strong> <em>{{ git_revision_date_localized }}</em></p>
<p>!!! note “Section Overview”</p>
<pre><code>&amp;#128368; **Time Estimation:** 40 minutes  

&amp;#128172; **Learning Objectives:**    

1. Explore different types of normalization methods
2. Become familiar with the `DESeqDataSet` object
3. Understand how to normalize counts using DESeq2</code></pre>
<p>The first step in the DE analysis workflow is count normalization, which is necessary to make accurate comparisons of gene expression between samples.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./img/05c_count_normalization/normalization_workflow.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="720"></p>
</figure>
</div>
</div>
</div>
<p>The counts of mapped reads for each gene is proportional to the expression of RNA (“interesting”) in addition to many other factors (“uninteresting”). Normalization is the process of scaling raw count values to account for the “uninteresting” factors. In this way the expression levels are more comparable between and/or within samples.</p>
<p>The main factors often considered during normalization are:</p>
<ul>
<li><strong>Sequencing depth:</strong> Accounting for sequencing depth is necessary for comparison of gene expression between samples. In the example below, each gene appears to have doubled in expression in <em>Sample A</em> relative to <em>Sample B</em>, however this is a consequence of <em>Sample A</em> having double the sequencing depth.</li>
</ul>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./img/05c_count_normalization/library_size_bias.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="720"></p>
</figure>
</div>
</div>
</div>
<p>!!! note</p>
<pre><code>In the figure above, each red rectangle represents a read aligned to a gene. Reads connected by dashed lines connect a read spanning an intron.</code></pre>
<ul>
<li><strong>Gene length:</strong> Accounting for gene length is necessary for comparing expression between different genes within the same sample. In the example, <em>Gene 2</em> and <em>Gene 3</em> have similar levels of expression, but the number of reads mapped to <em>Gene 2</em> would be many more than the number mapped to <em>Gene 3</em> because <em>Gene 2</em> is longer.</li>
</ul>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./img/05c_count_normalization/length_bias.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="720"></p>
</figure>
</div>
</div>
</div>
<ul>
<li><p><strong>GC-content</strong>: Genomic features such as GC-content may result in a read count biases, as GC-rich and GC-poor fragments are under-represented in RNAseq experiments. This under-representation is attributed to the fact that fragments with high and low GC-content are not adequately amplified in a standard high throughput sequencing protocol and, subsequently, that the fragments are difficult to align (correctly) to reference genome, i.e.&nbsp;less unique, repeat regions, etc. (<a href="https://academic.oup.com/nar/article/40/10/e72/2411059">Benjamini &amp; Speed, 2012</a> and <a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-12-480">Risso et al, 2011</a>).</p></li>
<li><p><strong>RNA composition:</strong> A few highly differentially expressed genes between samples, differences in the number of genes expressed between samples, or presence of contamination can skew some types of normalization methods. Accounting for RNA composition is recommended for accurate comparison of expression between samples, and is particularly important when performing differential expression analyses <a href="https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-10-r106">Anders &amp; Huber, 2010</a>.</p>
<p>In the example, if we were to divide each sample by the total number of counts to normalize, the counts would be greatly skewed by the DE gene, which takes up most of the counts for <em>Sample A</em>, but not <em>Sample B</em>. Most other genes for <em>Sample A</em> would be divided by the larger number of total counts and appear to be less expressed than those same genes in <em>Sample B</em>.</p></li>
</ul>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./img/05c_count_normalization/rna_composition_bias.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="720"></p>
</figure>
</div>
</div>
</div>
<p>!!! tip</p>
<pre><code>While normalization is essential for differential expression analyses, it is also necessary for exploratory data analysis, visualization of data, and whenever you are exploring or comparing counts between or within samples.</code></pre>
<section id="common-normalization-methods" class="level2">
<h2 class="anchored" data-anchor-id="common-normalization-methods">Common normalization methods</h2>
<p>Several common normalization methods exist to account for these differences:</p>
<p>{{ read_table(‘./assets/normalization_methods.tsv’) }}</p>
</section>
<section id="rpkmfpkm-not-recommended" class="level2">
<h2 class="anchored" data-anchor-id="rpkmfpkm-not-recommended">RPKM/FPKM (not recommended)</h2>
<p>While TPM and RPKM/FPKM normalization methods both account for sequencing depth and gene length, RPKM/FPKM are not recommended. <strong>The reason is that the normalized count values output by the RPKM/FPKM method are not comparable between samples.</strong></p>
<p>Using RPKM/FPKM normalization, the total number of RPKM/FPKM normalized counts for each sample will be different. Therefore, you cannot compare the normalized counts for each gene equally between samples.</p>
<p><strong>RPKM-normalized counts table</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>gene</th>
<th style="text-align: center;">sampleA</th>
<th style="text-align: center;">sampleB</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>XCR1</td>
<td style="text-align: center;">5.5</td>
<td style="text-align: center;">5.5</td>
</tr>
<tr class="even">
<td>WASHC1</td>
<td style="text-align: center;">73.4</td>
<td style="text-align: center;">21.8</td>
</tr>
<tr class="odd">
<td>…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
</tr>
<tr class="even">
<td>Total RPKM-normalized counts</td>
<td style="text-align: center;">1,000,000</td>
<td style="text-align: center;">1,500,000</td>
</tr>
</tbody>
</table>
<p>For example, in the table above, SampleA has a greater proportion of counts associated with XCR1 (5.5/1,000,000) than does sampleB (5.5/1,500,000) even though the RPKM count values are the same. Therefore, we cannot directly compare the counts for XCR1 (or any other gene) between sampleA and sampleB because the total number of normalized counts are different between samples.</p>
</section>
<section id="deseq2-normalized-counts-median-of-ratios-method" class="level2">
<h2 class="anchored" data-anchor-id="deseq2-normalized-counts-median-of-ratios-method">DESeq2-normalized counts: Median of ratios method</h2>
<p>Since tools for differential expression analysis are comparing the counts between sample groups for the same gene, gene length does not need to be accounted for by the tool. However, <strong>sequencing depth</strong> and <strong>RNA composition</strong> do need to be taken into account.</p>
<p>To normalize for sequencing depth and RNA composition, DESeq2 uses the median of ratios method. On the user-end there is only one step, but on the back-end there are multiple steps involved, as described below.</p>
<p>!!! note Note on the DESeq2 workflow</p>
<pre><code>The steps below describe in detail some of the steps performed by DESeq2 when you run a single function to get DE genes. Basically, for a typical RNA-seq analysis, **you would not run these steps individually**.</code></pre>
<section id="step-1-creates-a-pseudo-reference-sample-row-wise-geometric-mean" class="level3">
<h3 class="anchored" data-anchor-id="step-1-creates-a-pseudo-reference-sample-row-wise-geometric-mean">Step 1: creates a pseudo-reference sample (row-wise geometric mean)</h3>
<p>For each gene, a pseudo-reference sample is created that is equal to the geometric mean across all samples.</p>
<table class="table">
<thead>
<tr class="header">
<th>gene</th>
<th style="text-align: center;">sampleA</th>
<th style="text-align: center;">sampleB</th>
<th style="text-align: center;">pseudo-reference sample</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EF2A</td>
<td style="text-align: center;">1489</td>
<td style="text-align: center;">906</td>
<td style="text-align: center;">sqrt(1489 * 906) = <strong>1161.5</strong></td>
</tr>
<tr class="even">
<td>ABCD1</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">sqrt(22 * 13) = <strong>17.7</strong></td>
</tr>
<tr class="odd">
<td>…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
</tr>
</tbody>
</table>
</section>
<section id="step-2-calculates-ratio-of-each-sample-to-the-reference" class="level3">
<h3 class="anchored" data-anchor-id="step-2-calculates-ratio-of-each-sample-to-the-reference">Step 2: calculates ratio of each sample to the reference</h3>
<p>For every gene in a sample, the ratios (sample/ref) are calculated (as shown below). This is performed for each sample in the dataset. Since the majority of genes are not differentially expressed, the majority of genes in each sample should have similar ratios within the sample.</p>
<table class="table">
<colgroup>
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 25%">
<col style="width: 24%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>gene</th>
<th style="text-align: center;">sampleA</th>
<th style="text-align: center;">sampleB</th>
<th style="text-align: center;">pseudo-reference sample</th>
<th style="text-align: center;">ratio of sampleA/ref</th>
<th style="text-align: center;">ratio of sampleB/ref</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EF2A</td>
<td style="text-align: center;">1489</td>
<td style="text-align: center;">906</td>
<td style="text-align: center;">1161.5</td>
<td style="text-align: center;">1489/1161.5 = <strong>1.28</strong></td>
<td style="text-align: center;">906/1161.5 = <strong>0.78</strong></td>
</tr>
<tr class="even">
<td>ABCD1</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">16.9</td>
<td style="text-align: center;">22/16.9 = <strong>1.30</strong></td>
<td style="text-align: center;">13/16.9 = <strong>0.77</strong></td>
</tr>
<tr class="odd">
<td>MEFV</td>
<td style="text-align: center;">793</td>
<td style="text-align: center;">410</td>
<td style="text-align: center;">570.2</td>
<td style="text-align: center;">793/570.2 = <strong>1.39</strong></td>
<td style="text-align: center;">410/570.2 = <strong>0.72</strong></td>
</tr>
<tr class="even">
<td>BAG1</td>
<td style="text-align: center;">76</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">56.5</td>
<td style="text-align: center;">76/56.5 = <strong>1.35</strong></td>
<td style="text-align: center;">42/56.5 = <strong>0.74</strong></td>
</tr>
<tr class="odd">
<td>MOV10</td>
<td style="text-align: center;">521</td>
<td style="text-align: center;">1196</td>
<td style="text-align: center;">883.7</td>
<td style="text-align: center;">521/883.7 = <strong>0.590</strong></td>
<td style="text-align: center;">1196/883.7 = <strong>1.35</strong></td>
</tr>
<tr class="even">
<td>…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="step-3-calculate-the-normalization-factor-for-each-sample-size-factor" class="level3">
<h3 class="anchored" data-anchor-id="step-3-calculate-the-normalization-factor-for-each-sample-size-factor">Step 3: calculate the normalization factor for each sample (size factor)</h3>
<p>The median value (column-wise for the above table) of all ratios for a given sample is taken as the normalization factor (size factor) for that sample, as calculated below. Notice that the differentially expressed genes should not affect the median value:</p>
<p><code>normalization_factor_sampleA &lt;- median(c(1.28, 1.3, 1.39, 1.35, 0.59))</code></p>
<p><code>normalization_factor_sampleB &lt;- median(c(0.78, 0.77, 0.72, 0.74, 1.35))</code></p>
<p>The figure below illustrates the median value for the distribution of all gene ratios for a single sample (frequency is on the y-axis).</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./img/05c_count_normalization/deseq_median_of_ratios.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="326"></p>
</figure>
</div>
</div>
</div>
<p>The median of ratios method assumes that not ALL genes are differentially expressed; therefore, the normalization factors should account for sequencing depth and RNA composition of the sample (large outlier genes will not represent the median ratio values). <strong>This method is robust to imbalance in up-/down-regulation and large numbers of differentially expressed genes.</strong></p>
<p>!!! warning</p>
<pre><code>Usually, these size factors are around 1, if you see large variations between samples it is important to take note since it might indicate the presence of extreme outliers.</code></pre>
</section>
<section id="step-4-calculate-the-normalized-count-values-using-the-normalization-factor" class="level3">
<h3 class="anchored" data-anchor-id="step-4-calculate-the-normalized-count-values-using-the-normalization-factor">Step 4: calculate the normalized count values using the normalization factor</h3>
<p>This is performed by dividing each raw count value in a given sample by that sample’s normalization factor to generate normalized count values. This is performed for all count values (every gene in every sample). For example, if the median ratio for SampleA was 1.3 and the median ratio for SampleB was 0.77, you could calculate normalized counts as follows:</p>
<p>SampleA median ratio = 1.3</p>
<p>SampleB median ratio = 0.77</p>
<p><strong>Raw Counts</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>gene</th>
<th style="text-align: center;">sampleA</th>
<th style="text-align: center;">sampleB</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EF2A</td>
<td style="text-align: center;">1489</td>
<td style="text-align: center;">906</td>
</tr>
<tr class="even">
<td>ABCD1</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">13</td>
</tr>
<tr class="odd">
<td>…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
</tr>
</tbody>
</table>
<p><strong>Normalized Counts</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>gene</th>
<th style="text-align: center;">sampleA</th>
<th style="text-align: center;">sampleB</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EF2A</td>
<td style="text-align: center;">1489 / 1.3 = <strong>1145.39</strong></td>
<td style="text-align: center;">906 / 0.77 = <strong>1176.62</strong></td>
</tr>
<tr class="even">
<td>ABCD1</td>
<td style="text-align: center;">22 / 1.3 = <strong>16.92</strong></td>
<td style="text-align: center;">13 / 0.77 = <strong>16.88</strong></td>
</tr>
<tr class="odd">
<td>…</td>
<td style="text-align: center;">…</td>
<td style="text-align: center;">…</td>
</tr>
</tbody>
</table>
<p>!!! warning</p>
<pre><code>Please note that normalized count values are not whole numbers.</code></pre>
<p>!!! question “<strong>Exercise 1</strong>”</p>
<pre><code>Determine the normalized (median of ratios) counts for your gene of interest, PD1, given the raw counts and size factors below. 

NOTE: You will need to run the code below to generate the raw counts dataframe (PD1) and the size factor vector (size_factors), then use these objects to determine the normalized counts values:


::: {.cell layout-align="center"}

```{.r .cell-code}
# Raw counts for PD1
PD1 &lt;- t(c(21, 58, 17, 97, 83, 10)) %&gt;% 
as_tibble() %&gt;%
rename_all(~paste0("Sample", 1:6))


# Size factors for each sample
size_factors &lt;- c(1.32, 0.70, 1.04, 1.27, 1.11, 0.85)
```
:::</code></pre>
<p>??? question “<strong>Solution to Exercise 1</strong>”</p>
<pre><code>Let's check first what is PD1


::: {.cell layout-align="center"}

```{.r .cell-code}
PD1
```
:::


Since we have the size factors per sample, we only need to divide our PD1 counts by the size factors!


::: {.cell layout-align="center"}

```{.r .cell-code}
PD1/size_factors
```
:::</code></pre>
</section>
</section>
<section id="count-normalization-of-the-vampirium-dataset-using-deseq2" class="level2">
<h2 class="anchored" data-anchor-id="count-normalization-of-the-vampirium-dataset-using-deseq2">Count normalization of the Vampirium dataset using DESeq2</h2>
<p>Now that we know the theory of count normalization, we will normalize the counts for the Vampirium dataset using DESeq2. This requires a few steps:</p>
<ol type="1">
<li>Ensure the row names of the metadata dataframe are present and in the same order as the column names of the counts dataframe.</li>
<li>Create a <code>DESeqDataSet</code> object</li>
<li>Generate the normalized counts</li>
</ol>
<section id="match-the-metadata-and-counts-data" class="level3">
<h3 class="anchored" data-anchor-id="match-the-metadata-and-counts-data">1. Match the metadata and counts data</h3>
<p>We should always make sure that we have sample names that match between the two files, and that the samples are in the right order. DESeq2 will output an error if this is not the case. Since we built our <code>txi</code> object from our metadata, everything should be OK.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Check that sample names match in both files</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span>(<span class="fu">colnames</span>(txi<span class="sc">$</span>counts) <span class="sc">%in%</span> meta<span class="sc">$</span>sample)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span>(<span class="fu">colnames</span>(txi<span class="sc">$</span>counts) <span class="sc">==</span> meta<span class="sc">$</span>sample)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If your data did not match, you could use the <code>match()</code> function to rearrange them to be matching. <code>match()</code> function will take two arguments and find in which order the indexes of the second argument match the first argument.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"a"</span>,<span class="st">"b"</span>,<span class="st">"c"</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"b"</span>,<span class="st">"c"</span>,<span class="st">"a"</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>reorder <span class="ot">&lt;-</span> <span class="fu">match</span>(a,b)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>reorder</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>b[reorder]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>!!! question “<strong>Exercise 2</strong>”</p>
<pre><code>Suppose we had sample names matching in the txi object and metadata file, but they were out of order. Write the line(s) of code required make the `meta_random` dataframe with rows ordered such that they were identical to the column names of the `txi`.


::: {.cell layout-align="center"}

```{.r .cell-code}
# randomize metadata rownames
meta_random &lt;- meta[sample(1:nrow(meta)),]
```
:::</code></pre>
<p>??? question “<strong>Solution to Exercise 2</strong>”</p>
<pre><code>Let's check now meta_random order:


::: {.cell layout-align="center"}

```{.r .cell-code}
meta_random
```
:::


We can see that it is all scrambled. We want the rows of `meta_random` to be the same order as the columns of the `txi@counts` object (which is not, as you can see below):


::: {.cell layout-align="center"}

```{.r .cell-code}
### Check that sample names match in both files
all(colnames(txi$counts) %in% meta_random$sample) # are all samples in our metadata?
all(colnames(txi$counts) == meta_random$sample) # are all samples in the same order?
```
:::


Let's use the match function. First we find the order that `meta_random$sample` should be to match the columns of `txi@counts`:


::: {.cell layout-align="center"}

```{.r .cell-code}
reorder &lt;- match(colnames(txi$counts),meta_random$sample)
reorder
```
:::


Finally, we change the order of the rows of meta_random:


::: {.cell layout-align="center"}

```{.r .cell-code}
meta_random &lt;- meta_random[reorder,]
meta_random
```
:::


And confirm:


::: {.cell layout-align="center"}

```{.r .cell-code}
all(colnames(txi$counts) == meta_random$sample) # are all samples in the same order?
```
:::</code></pre>
</section>
<section id="create-deseq2-object" class="level3">
<h3 class="anchored" data-anchor-id="create-deseq2-object">2. Create DESEq2 object</h3>
<p>Bioconductor software packages often define and use a custom class within R for storing data (input data, intermediate data and also results). These custom data structures are similar to <code>lists</code> in that they can contain multiple different data types/structures within them. But, unlike lists they have pre-specified <code>data slots</code>, which hold specific types/classes of data. The data stored in these pre-specified slots can be accessed by using specific package-defined functions.</p>
<p>Let’s start by creating the <code>DESeqDataSet</code> object, and then we can talk a bit more about what is stored inside it. To create the object, we will need the <strong>txi</strong> object and the <strong>metadata</strong> table as input (<code>colData</code> argument). We will also need to specify a <strong>design formula</strong>. The design formula specifies which column(s) of our metadata we want to use for statistical testing and modeling (more about that later!). For our dataset we only have one column we are interested in, which is <code>condition</code>. This column has three factor levels, which tells DESeq2 that for each gene we want to evaluate gene expression change with respect to these different levels.</p>
<p><strong>It is very important to establish beforehand which sample type will be our “base” or “reference” level.</strong> If nothing is changed, DESeq2 will assume that our reference samples will be the first sample type (in alphabetical order). You can check this using the <code>factor()</code> function.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">factor</span>(meta<span class="sc">$</span>condition)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>While in a normal experiment we would use control samples as our reference, in our case we are interested in both checking the differences between control vs.&nbsp;vampirium and garlicum vs.&nbsp;vampirium. Thus, it would be much more convinient to reorganize our factor base level to <code>vampirium</code>. We can do this also with the <code>factor()</code> function, using the <code>levels =</code> argument.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>meta<span class="sc">$</span>condition <span class="ot">=</span> <span class="fu">factor</span>(meta<span class="sc">$</span>condition, <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"vampirium"</span>, <span class="st">"control"</span>, <span class="st">"garlicum"</span>))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">factor</span>(meta<span class="sc">$</span>condition)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can see now that vampirium is the first factor! Meaning that it will be interpreted by DESeq as our reference sample type.</p>
<p><strong>Our count matrix input is stored in the <code>txi</code> list object</strong>. So we need to specify that using the <code>DESeqDataSetFromTximport()</code> function, which will extract the counts component and round the values to the nearest whole number.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># colData argument requires rownames in order to assess matching sample names</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co"># meta is a tibble object from tidyverse, so we neeed to add rownames.</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"># If you do not do this and the samples do not match, you will add wrong info!</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>dds <span class="ot">&lt;-</span> <span class="fu">DESeqDataSetFromTximport</span>(txi,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">colData =</span> meta <span class="sc">%&gt;%</span> <span class="fu">column_to_rownames</span>(<span class="st">"sample"</span>), </span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>                              <span class="at">design =</span> <span class="sc">~</span> condition)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>??? note “Control is not reference level warning”</p>
<pre><code>The warning from the chunk before is telling us that we have setup our vampirium samples as reference, instead of control! This is exactly what we wanted.</code></pre>
<p>??? note “Starting from a traditional count matrix”</p>
<pre><code>If you did not create pseudocounts, but a count matrix from aligned BAM files and tools such as `featurecounts`, you would want to use the `DESeqDataSetFromMatrix()` function.


::: {.cell layout-align="center"}

```{.r .cell-code}
## DO NOT RUN!
## Create DESeq2Dataset object from traditional count matrix
dds &lt;- DESeqDataSetFromMatrix(countData = "../Data/Vampirium_counts_traditional.tsv", 
                          colData = meta %&gt;% column_to_rownames("sample"), 
                          design = ~ condition)
```
:::</code></pre>
<p>You can use DESeq-specific functions to access the different slots and retrieve information, if you wish. For example, suppose we wanted the original count matrix we would use <code>counts()</code> (<em>Note: we nested it within the <code>View()</code> function so that rather than getting printed in the console we can see it in the script editor</em>) :</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">View</span>(<span class="fu">counts</span>(dds))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As we go through the workflow we will use the relevant functions to check what information gets stored inside our object.</p>
<p>You can use DESeq-specific functions to access the different slots and retrieve information, if you wish. For example, suppose we wanted the original count matrix we would use <code>counts()</code>:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">counts</span>(dds))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As we go through the workflow we will use the relevant functions to check what information gets stored inside our object.</p>
<section id="pre-filtering" class="level4">
<h4 class="anchored" data-anchor-id="pre-filtering">Pre-filtering</h4>
<p>While it is not necessary to pre-filter low count genes before running the DESeq2 functions, there are two reasons which make pre-filtering useful:</p>
<ul>
<li>By removing rows in which there are very few reads, we reduce the memory size of the dds data object, and we increase the speed of the transformation and testing functions within DESeq2.</li>
<li>It can also improve visualizations, as features with no information for differential expression are not plotted.</li>
</ul>
<p>Here we perform a minimal pre-filtering to keep only rows that have at least 10 reads total.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>keep <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(<span class="fu">counts</span>(dds)) <span class="sc">&gt;=</span> <span class="dv">10</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>dds <span class="ot">&lt;-</span> dds[keep,]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="generate-the-normalized-counts" class="level3">
<h3 class="anchored" data-anchor-id="generate-the-normalized-counts">3. Generate the normalized counts</h3>
<p>The next step is to normalize the count data in order to be able to make fair gene comparisons between samples.</p>
<p>To perform the <strong>median of ratios method</strong> of normalization, DESeq2 has a single <code>estimateSizeFactors()</code> function that will generate size factors for us. We will use the function in the example below, but <strong>in a typical RNA-seq analysis this step is automatically performed by the <code>DESeq()</code> function</strong>, which we will see later.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>dds <span class="ot">&lt;-</span> <span class="fu">estimateSizeFactors</span>(dds)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>By assigning the results back to the <code>dds</code> object we are filling in the slots of the <code>DESeqDataSet</code> object with the appropriate information. We can take a look at the normalization factor applied to each sample using:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sizeFactors</span>(dds)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, to retrieve the normalized counts matrix from <code>dds</code>, we use the <code>counts()</code> function and add the argument <code>normalized=TRUE</code>.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>normalized_counts <span class="ot">&lt;-</span> <span class="fu">counts</span>(dds, <span class="at">normalized=</span><span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can save this normalized data matrix to file for later use:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">write.table</span>(normalized_counts, <span class="at">file=</span><span class="st">"/work/Intro_to_bulkRNAseq/Results/normalized_counts.txt"</span>, <span class="at">sep=</span><span class="st">"</span><span class="sc">\t</span><span class="st">"</span>, <span class="at">quote=</span>F)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>!!! warning</p>
<pre><code>DESeq2 doesn't actually use normalized counts, rather it uses the raw counts and models the normalization inside the Generalized Linear Model (GLM). These normalized counts will be useful for downstream visualization of results, but cannot be used as input to DESeq2 or any other tools that perform differential expression analysis which use the negative binomial model.</code></pre>
<hr>
<p><em>This lesson was originally developed by members of the teaching team (Mary Piper, Meeta Mistry, Radhika Khetani) at the <a href="http://bioinformatics.sph.harvard.edu/">Harvard Chan Bioinformatics Core (HBC)</a>.</em></p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>