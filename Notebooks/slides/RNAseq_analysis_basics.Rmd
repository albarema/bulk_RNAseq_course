---
title: "bulk RNAseq basics"
author: "Jose Alejandro Romero Herrera"
date: '`r Sys.Date()`'
knit: (function(inputFile, encoding) { 
      rmarkdown::render(inputFile,
                        encoding=encoding,
                        output_format='all',
                        output_dir='./reports/')})
output:
  # To create PDF report, uncomment below
  #pdf_document:
  #  toc: yes
  # html_document:
  #   number_sections: yes
  #   theme: yeti
  #   toc: yes
  #   toc_float: yes
  #   df_print: paged
  #   dev: png
  md_document
---

```{r knitr, include = FALSE}
DOCNAME = knitr::current_input()
knitr::opts_chunk$set(autodep        = TRUE,
                      cache          = FALSE,
                      cache.path     = paste0("cache/", DOCNAME, "/"),
                      cache.comments = TRUE,
                      echo           = TRUE,
                      error          = FALSE,
                      fig.align      = "center",
                      fig.path       = paste0("./figures/", DOCNAME, "/"),
                      fig.width      = 10,
                      fig.height     = 8,
                      message        = FALSE,
                      warning        = FALSE)
```

# Introduction

This is a basic bulk RNAseq analysis using the package **DESeq2** and **gprofiler2** for Differential Expression Analysis and Functional Annotation. The code is a modified version of the [DESeq2](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) and [gprofiler2](https://cran.r-project.org/web/packages/gprofiler2/vignettes/gprofiler2.html) vignettes. The data used for this example below is the *pasilla* dataset: an RNAseq experiment that studied the effect of RNAi knockdown of Pasilla, the Drosophila melanogaster ortholog of mammalian NOVA1 and NOVA2, on the transcriptome.

# Load libraries
```{r, results='hide'}
library(tidyverse, quietly = T)
library(DESeq2, quietly = T)
library(RColorBrewer, quietly = T)
library(pheatmap, quietly = T)
library(gprofiler2, quietly = T)
library(Glimma, quietly = T)
```

# Load data
In order to proceed with the analysis we need two dataframes:
- Count matrix dataframe with gene names as rows (and rownames) and samples as columns (and column names). 
- Sample metadata dataframe with samples as rows (and rownames) and metadata variables as columns (and column names).

Additionally, you can add information about your features (genes), with genes as rows and gene metadata on columns.

Ideally, the sample metadata will contain information about the conditions, treatments, replicates, etc.

The pasilla dataset contains a count matrix and the metadata, which is a good example to use as a template. The count matrix looks like this:
```{r}
cts <- data.frame(read.csv(file = "../../data/example_data/pasilla_cts.tsv", sep="\t", row.names="flybase_id"))
head(cts)
```

While the sample metadata looks like this:
```{r}
coldata <- read.csv(file = "../../data/example_data/pasilla_metadata.tsv", row.names=1, sep = "\t")
head(coldata)
```

Making the metadata factors will establish the order of the metadata variables. If you never tell the DESeq2 functions which level you want to compare against (e.g. which level represents the control group), the comparisons will be based on the alphabetical order of the levels. This is important since the first level of the metadata will be the reference sample/condition for the DE analysis.
```{r}
coldata$condition <- factor(coldata$condition)
paste("The order of the conditions is:", paste(unique(coldata$condition), collapse=", "))
coldata$type <- factor(coldata$type)
paste("The order of the types is:", paste(unique(coldata$type), collapse=", "))
```

## Metadata factor levels
If you want to change the order of the factor levels you can use one of these two.
NOTE: this has to be done before running the `DESeq()` function.
```{r}
#coldata$condition <- factor(coldata$condition, levels = c("untreated","treated"))
coldata$condition <- relevel(coldata$condition, ref = "untreated") #Specifies "untreated" as the reference level
```

## Create DESeq object
We create the DESeq object from the count matrix and the metadata. We specify that the analysis will be based on the design column.
```{r}
dds <- DESeqDataSetFromMatrix(countData = cts,
                              colData = coldata, rowData = rownames(cts),
                              design = ~ condition)
dds
```
## Pre-filtering
We can reduce the computational resources of the analysis by removing genes that are very hardly expressed. Additionally, you can collapse technical replicates using the function `collapseReplicates()`.

```{r}
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
```

## Normalization
Finally the `DESeq()` function will normalize your read counts and estimate size factors per genes. This function is essential for the rest of the analysis.

```{r}
dds <- DESeq(dds)
```

# Exploratory analysis
After running the `DESeq()` function, we can start our RNAseq analysis by exploring the relationships between our samples. In principle, all replicates for a specific condition should be similar to each other after normalization. Should this not be the case, one might need to remove outlier replicates. This is one of the reasons why RNAseq experiments need at least 3 replicates per condition. 

## Data transformations
For visualization and clustering (exploratory analyses) – it might be useful to work with transformed versions of the count data. There are two main methods used for this purpose: variance stabilizing transformations (**VST**), and the regularized logarithm or **rlog**. Both transformations produce transformed data on the log2 scale which has been normalized with respect to library size or other normalization factors.

```{r}
vsd <- vst(dds) #Variance Stabilizing Transformation, vst is faster with larger number of samples
rld <- rlog(dds) #Regularized 
```

## Samples comparisons 
We can do some sanity checks of the samples. We can see how they correlate to each other in a heatmap or see their Principal Components with a PCA plot.

### Heatmap of the sample-to-sample distances
This plot shows how far away are each sample from each other. The darker the blue, the closer they are.
```{r, sample_distances_heatmap}
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$condition, vsd$type, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```

### Principal component plot of the samples
PCA plot using the first two components
```{r PCA_plot}
pcaData <- plotPCA(vsd, intgroup=c("condition", "type"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=condition, shape=type)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed() + theme_bw()
```
### Glimma plots
Interactive visualizations of the DESeq results using the **Glimma** package, which provides excellent options for MA, Volcano and dimensionality reduction (like a PCA) plots. Use the *groups* argument to provide the condition or factor of your experiment. Unfortunately, the interactive plots created here are not fully compatible when knitting this document. Feel free to explore them using this [link](./mds-plot.html)!

```{r}
#glimmaMDS(dds, groups = dds$condition)
```

Save your interactive plots using the **htmlwidgets** packages, specifically, the `saveWidget()` 
```{r}
#htmlwidgets::saveWidget(glimmaMDS(dds, groups = dds$condition), "mds-plot.html")
```

## Plot counts
It can be useful to examine the counts of reads for a single gene across the conditions. A simple function for making this plot is plotCounts, which normalizes counts by the estimated size factors (or normalization factors if these were used) and adds a pseudocount of 1/2 to allow for log scale plotting. The counts are grouped by the variables in *intgroup* argument, where more than one variable can be specified. You can select the gene to plot by its name or by numeric index.

```{r plot_counts_example, fig.height=5, fig.width=5}
d <- plotCounts(dds, gene= 1, intgroup="condition", 
                returnData=TRUE)
ggplot(d, aes(x=condition, y=count, color = condition)) + 
  geom_point(position=position_jitter(w=0.1,h=0)) + 
  scale_y_log10(breaks=c(25,100,400)) + theme_bw()
```

# Differential expression analysis
In order to test for differential expression, we operate on raw counts and use discrete distributions
After checking that our samples are well correlated within conditions, we can proceed to test for Differantially Expressed Genes using the *results()* function.

```{r}
res <- results(dds)
head(data.frame(res))
```

Information about the results columns can be retrieved using the following snippet:
```{r}
mcols(res)$description
```

In this example, we only have two conditions: "untreated" and "treated", so there is no need to specify which comparison we would like to make.
If your experiment contains more than two conditions, there are different ways of specifying which comparison you would like to make.

First, the "contrast" argument will take a vector that specifies the metadata and the order of the comparison. In this case, you can swap the order of the condition levels.
```{r}
res <- results(dds, contrast=c("condition","untreated","treated"))
head(data.frame(res))
```

Second, "name" argument will use the results of the *resultsNames()* function. This function creates possible combinations of conditions, but always using the reference condition for the comparison.
```{r}
resultsNames(dds)
res <- results(dds, name="condition_treated_vs_untreated")
head(data.frame(res))
```

The notebook *contrast_design.Rmd* contains information about how to understand and define contrasts using model matrices, which might be a more intuitive way of comparing samples or conditions.

## Extracting results
The output of the *res()* function is the one you want to use/save to identify differentially expressed genes using log2 Fold Change or adjusted p-value thresholds.

There is a chance that the adjusted p-value is NA. If you will work on this results, it might be helpful to change all NA to an adjusted p-value of 1.
```{r}
res$padj[is.na(res$padj)] <- 1
```

We can have a quick look of the adjusted p-value results by using the following custom function:
```{r}
results_summary <- function(x, alpha = 0.05, LFC = 1) {
  ngenes <- nrow(x)
  signif <- sum(x$padj < alpha, na.rm = T)
  up <- sum(x$padj < alpha & x$log2FoldChange > LFC, na.rm = T)
  down <- sum(x$padj < alpha & x$log2FoldChange < -LFC, na.rm = T)
  results <- c(paste0("Number of genes: ", ngenes),
    paste0("Number of genes with adjusted p-value < ",alpha,": ", signif, " (", round((signif/ngenes)*100,digits = 2),"%)"),
    "  Of those:",
    paste0("    with LFC < ", -LFC, ": ", down, " (", round((down/ngenes)*100,digits = 2),"%)"),
    paste0("    with LFC > ", LFC, ": ", up, " (", round((up/ngenes)*100,digits = 2),"%)"))
  writeLines(paste(results, collapse = "\n"))
  return(paste(results, collapse = "\n"))
}
```


```{r}
res_summary <- results_summary(res, alpha = 0.05, LFC = 1)
```

### Save significant results
Extracting results based on adjusted p-value and LFC. this way we will get a filteres table with genes with LFC > 1 or LFC < -1 with an adjusted p-value of 0.05
```{r}
LFC <- 1
adj_pvalue <- 0.05

sig_res <- res[res$padj < adj_pvalue & abs(res$log2FoldChange) > LFC,]
#write.table(x = sig_res, "./significant_results.tsv", quote = F, col.names = T, row.names = T, sep = "\t")
```

# DEA visualizations 
## Count matrix heatmaps
We can visualize different heatmaps depending on what we are interested on. We can see the top most expressed genes, the top most variable genes and the DE genes.

### Top most variable genes
```{r most_var_genes_heatmap}
ntop <- 20
select <- order(rowSds(counts(dds,normalized=TRUE)),
                decreasing=TRUE)[1:ntop]
df <- as.data.frame(colData(dds)[,c("condition","type")])
pheatmap(assay(vsd)[select,], cluster_rows=T, show_rownames=FALSE, scale = "row",
         cluster_cols=FALSE, annotation_col=df)
```

### Top expressed genes
```{r top_exp_genes_heatmap}
ntop <- 20
select <- order(rowMeans(counts(dds,normalized=TRUE)),
                decreasing=TRUE)[1:ntop]
df <- as.data.frame(colData(dds)[,c("condition","type")])
pheatmap(assay(vsd)[select,], cluster_rows=FALSE, show_rownames=FALSE,
         cluster_cols=FALSE, annotation_col=df)
```

### Differentially expressed genes
```{r DEA_heatmap}
select <- rownames(sig_res)
df <- as.data.frame(colData(dds)[,c("condition","type")])
pheatmap(assay(vsd)[rownames(vsd) %in% select,], cluster_rows=TRUE, show_rownames=FALSE, scale = "row",
         cluster_cols=FALSE, annotation_col=df)
```

## Fold change plots
For fold change plots, it is useful to shrunk log2 fold changes, which removes the noise associated with log2 fold changes from low count genes without requiring arbitrary filtering thresholds.
```{r}
resLFC <- lfcShrink(dds, coef="condition_treated_vs_untreated", type="apeglm")
resLFC$padj[is.na(resLFC$padj)] <- 1
```

### MA plot
```{r MA_plot}
alpha <- 0.05

ggplot(data.frame(resLFC)) + theme_bw() + 
  labs(title = "MA plot", subtitle = res_summary,
       color = paste0("Adjusted p-value < ",alpha)) +
  geom_point(aes(x = log10(baseMean), y = log2FoldChange, 
                 color = factor((padj < alpha), levels = c("TRUE","FALSE"))), size = 1)
```

### Volcano plot
```{r volcano_plot}
alpha = 0.05
LFC = 1
ggplot(data.frame(resLFC)) + theme_bw() + 
  labs(color ="Significant genes", title = "Volcano plot", subtitle = res_summary) + 
  geom_hline(yintercept = -log10(alpha), linetype = "dashed") + 
  geom_vline(xintercept = c(-LFC,LFC), linetype = "dashed") + 
  geom_point(aes(x = log2FoldChange, y = -log10(padj),
                 color = factor((padj < alpha & abs(log2FoldChange) > LFC), levels = c("TRUE","FALSE"))), size = 1)
```

### Glimma plots
We can visualize our results interactively using the `glimmaMA()` and `glimmaVolcano()` functions.

```{r}
#glimmaMA(dds, groups = dds$condition)
#glimmaVolcano(dds, groups = dds$condition)
```

Save your interactive plots using the `htmlwidgets::saveWidget()` function.
```{r}
#htmlwidgets::saveWidget(glimmaMA(dds, groups = dds$condition), "ma-plot.html")
#htmlwidgets::saveWidget(glimmaVolcano(dds, groups = dds$condition), "volcano-plot.html")
```

# Functional analysis with gprofiler2
`gost()` function allows us to do functional profiling of gene lists, such as our differentially expressed genes. The function performs statistical enrichment analysis to find over-representation of terms from Gene Ontology, biological pathways like KEGG and Reactome, human disease annotations, etc. This is done by using hypergeometric tests that are corrected for multiple testing.

## Single query
A standard input of the `gost()` function is a (named) list of gene identifiers. The list can consist of mixed types of identifiers (proteins, transcripts, microarray IDs, etc), SNP IDs, chromosomal intervals or functional term IDs.

The result is a named list where *result* is a data.frame with the enrichment analysis results and *meta* containing a named list with all the metadata for the query.

```{r}
gostres <- gost(query = rownames(sig_res), 
                organism = "dmelanogaster", ordered_query = FALSE, 
                multi_query = FALSE, significant = FALSE, exclude_iea = FALSE, 
                measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = NULL, as_short_link = FALSE)

head(gostres$result)
```

The result data.frame contains the following columns:
```{r}
names(gostres$meta)
```

## Multiple queries
The function `gost()` also allows to perform enrichment on multiple input gene lists. Multiple queries are automatically detected if the input query is a list of vectors with gene identifiers and the results are combined into identical data.frame as in case of single query.
```{r}
multi_gostres1 <- gost(query = list("chromX" = c("X:1000:1000000", "rs17396340", 
                                                 "GO:0005005", "ENSG00000156103", "NLRP1"),
                             "chromY" = c("Y:1:10000000", "rs17396340", 
                                          "GO:0005005", "ENSG00000156103", "NLRP1")), 
                       multi_query = FALSE)

head(multi_gostres1$result, 3)
```

The column “query” in the result dataframe will now contain the corresponding name for the query. If no name is specified, then the query name is defined as the order of query with the prefix “query_.”
Another option for multiple gene lists is setting the parameter `multiquery = TRUE`. Then the results from all of the input queries are grouped according to term IDs for better comparison.

```{r}
multi_gostres2 <- gost(query = list("chromX" = c("X:1000:1000000", "rs17396340",
                                                 "GO:0005005", "ENSG00000156103", "NLRP1"),
                             "chromY" = c("Y:1:10000000", "rs17396340", 
                                          "GO:0005005", "ENSG00000156103", "NLRP1")), 
                       multi_query = TRUE)

head(multi_gostres2$result, 3)
```

## Visualization
The enrichment results are visualized with a Manhattan-like-plot using the function `gostplot()` and the previously found gost results *gostres*:

```{r gost_interactive}
gostplot(gostres, capped = TRUE, interactive = TRUE)
```

The function `publish_gostplot()` takes the static plot object as an input and enables to highlight a selection of interesting terms from the results with numbers and table of results. These can be set with parameter highlight_terms listing the term IDs in a vector or as a data.frame with column “term_id” such as a subset of the result dataframe.

First we create the static plot
```{r gost_static}
p <- gostplot(gostres, capped = FALSE, interactive = FALSE)
p
```

Then we make it in high quality. We can add highlighted terms if we want with the *highlight_terms* argument.
```{r gost_publishing}
pp <- publish_gostplot(p, highlight_terms = c("GO:0005372"),
                       width = NA, height = NA, filename = NULL )
```

The gost results can also be visualized with a table. The `publish_gosttable()` function will create a nice-looking table with the result statistics for the highlight_terms from the result data.frame. The highlight_terms can be a vector of term IDs or a subset of the results.

```{r gost_table, fig.height=5, fig.width=10}
publish_gosttable(gostres, highlight_terms = gostres$result[c(1:10),],
                        use_colors = TRUE, 
                        show_columns = c("source", "term_name", "term_size", "intersection_size"),
                        filename = NULL) 
```

# Session info
Finally, we create a `session_info()` table that will allow anyone to check what versions of R and packages are we using for reproducibility purposes.

```{r session-info}
devtools::session_info()
```