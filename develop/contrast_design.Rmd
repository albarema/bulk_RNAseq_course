---
title: "Setting DESeq contrasts\n(using the model matrix)"
author: "Modified from Hugo Tavares"
date: '`r Sys.Date()`'
knit: (function(inputFile, encoding) { 
      rmarkdown::render(inputFile,
                        encoding=encoding,
                        output_format='all',
                        output_dir='./reports/')})
output:
  # To create PDF report, uncomment below
  #pdf_document:
  #  toc: yes
  html_document:
    number_sections: yes
    theme: yeti
    toc: yes
    toc_float: yes
    df_print: paged
    dev: png
---

```{r knitr, include = FALSE}
DOCNAME = knitr::current_input()
knitr::opts_chunk$set(autodep        = TRUE,
                      cache          = FALSE,
                      cache.path     = paste0("cache/", DOCNAME, "/"),
                      cache.comments = TRUE,
                      echo           = TRUE,
                      error          = FALSE,
                      fig.align      = "center",
                      fig.path       = paste0("./figures/", DOCNAME, "/"),
                      fig.width      = 10,
                      fig.height     = 8,
                      message        = FALSE,
                      warning        = FALSE)
```


```{r setup, include=FALSE}
set.seed(10)
```

```{r, message=FALSE, echo=FALSE}
library(DESeq2)
```

In this tutorial we show how to set treatment contrasts in **DESeq2** using the design or model matrix, explained on module [4. Differential Expression Analysis](../../Slides/4_DEA.pptx).
This is a general and flexible way to define contrasts, and is often useful for more complex contrasts or when the design of the experiment is imbalanced (e.g. different number of replicates in each group). 
Although we focus on **DESeq2**, the approach can also be used with the other popular package **edgeR**.

Each section below covers a particular experimental design, from simpler to more complex ones. 
The first chunk of code in each section is to simulate data, which has no particular meaning and is only done in order to have a DESeqDataSet object with the right kind of variables for each example. 
In practice, users can ignore this step as they should have created a DESeqDataSet object from their own data following the [instructions in the vignette](https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#the-deseqdataset). 


# One factor, two levels (slide 5)

```{r}
# simulate data
dds <- makeExampleDESeqDataSet(n = 1000, m = 6, betaSD = 2)
dds$condition <- factor(rep(c("control", "treat"), each = 3))
```

First we can look at our sample information:

```{r}
colData(dds)
```

Our factor of interest is `condition` and so we define our design and run the DESeq model fitting routine:

```{r, message=FALSE}
design(dds) <- ~ 1 + condition # or just `~ condition`
dds <- DESeq(dds) # equivalent to edgeR::glmFit()
```

Then check what coefficients DESeq estimated:

```{r}
resultsNames(dds)
```

We can see that we have a coefficient for our _intercept_ and coefficient for the effect of "treat" (i.e. differences between treat versus control). 

Using the more standard syntax, we can obtain the results for the effect of treat as such:

```{r}
res1 <- results(dds, contrast = list("condition_treat_vs_control"))
res1
```

The above is a simple way to obtain the results of interest. 
But it is worth understanding how DESeq is getting to these results by looking at the model's matrix. 
DESeq defines the model matrix using base R functionality:

```{r}
model.matrix(design(dds), colData(dds))
```

We can see that R coded "condition" as a dummy variable, with an intercept (common to all samples) and a "conditiontreat" variable, which adds the effect of treat to samples 4-6. 

We can actually set our contrasts in `DESeq2::results()` using a numeric vector. 
The way it works is to define a vector of "weights" for the coefficient(s) we want to test for.
In this case, we have `(Intercept)` and `conditiontreat` as our coefficients (see model matrix above), and we want to test for the effect of treat, so our contrast vector would be `c(0, 1)`. 
In other words, we don't care about the value of `(Intercept)` (so it has a weight of 0), and we're only interested in the effect of treat (so we give it a weight of 1). 

In this case the design is very simple, so we could define our contrast vector "manually". But for complex designs this can get more difficult to do, so it's worth mentioning the general way in which we can define this. 
For any contrast of interest, we can follow three steps:

- Get the model matrix
- Subset the matrix for each group of interest and calculate its column means - this results in a vector of coefficients for each group
- Subtract the group vectors from each other according to the comparison we're interested in

Let's see this example in action:

```{r}
# get the model matrix
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat
```

```{r}
# calculate the vector of coefficient weights in the treat
treat <- colMeans(mod_mat[dds$condition == "treat", ])
treat
```

```{r}
# calculate the vector of coefficient weights in the control
control <- colMeans(mod_mat[dds$condition == "control", ])
control
```

```{r}
# The contrast we are interested in is the difference between treat and control
treat - control
```

That last step is where we define our contrast vector, and we can give this directly to the `results` function:

```{r}
# get the results for this contrast
res2 <- results(dds, contrast = treat - control)
```

This gives us exactly the same results as before, which we can check for example by plotting the log-fold-changes between the first and second approach:

```{r, eval=FALSE}
plot(res1$log2FoldChange, res2$log2FoldChange)
```


## Recoding the design (slide 6)

Often, we can use different model matrices that essentially correspond to the same design. 
For example, we could recode our design above by removing the intercept:

```{r, message=FALSE}
design(dds) <- ~ 0 + condition
dds <- DESeq(dds)
resultsNames(dds)
```

In this case we get a coefficient corresponding to the average expression in control and the average expression in the treat (rather than the _difference_ between treat and control).

If we use the same contrast trick as before (using the model matrix), we can see the result is the same:

```{r}
# get the model matrix
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat
# calculate weights for coefficients in each condition
treat <- colMeans(mod_mat[which(dds$condition == "treat"), ])
control <- colMeans(mod_mat[which(dds$condition == "control"), ])
# get the results for our contrast
res3 <- results(dds, contrast = treat - control)
```

Again, the results are essentially the same:

```{r, eval=FALSE}
plot(res1$log2FoldChange, res3$log2FoldChange)
```

In theory there's no difference between these two ways of defining our design. 
The design with an intercept is more common, but for the purposes of understanding what's going on, it's sometimes easier to look at models without intercept. 


# One factor, three levels (slide 7)

```{r}
# simulate data
dds <- makeExampleDESeqDataSet(n = 1000, m = 9, betaSD = 2)
dds$condition <- NULL
dds$bloodtype <- factor(rep(c("bloodA", "bloodB", "bloodO"), each = 3))
dds$bloodtype <- relevel(dds$bloodtype, "bloodO")
```

First we can look at our sample information:

```{r}
colData(dds)
```

As in the previous example, we only have one factor of interest, `condition`, and so we define our design and run the DESeq as before:

```{r, message=FALSE}
design(dds) <- ~ 1 + bloodtype
dds <- DESeq(dds)
# check the coefficients estimated by DEseq
resultsNames(dds)
```

We see that now we have 3 coefficients: 

- "Intercept" corresponds to bloodO bloodtype (our reference level)
- "bloodtype_bloodA_vs_bloodO" corresponds to the difference between the reference level and bloodA
- "bloodtype_bloodB_vs_bloodO" corresponds to the difference between the reference level and bloodB

We could obtain the difference between bloodO and any of the two bloodtypes easily:

```{r}
res1_bloodA_bloodO <- results(dds, contrast = list("bloodtype_bloodA_vs_bloodO"))
res1_bloodB_bloodO <- results(dds, contrast = list("bloodtype_bloodB_vs_bloodO"))
```

For comparing bloodA vs bloodB, however, we need to compare two coefficients with each other to check whether they are themselves different (check the slide to see the illustration). This is how the standard DESeq syntax would be:

```{r}
res1_bloodA_bloodB <- results(dds, contrast = list("bloodtype_bloodA_vs_bloodO", 
                                                 "bloodtype_bloodB_vs_bloodO"))
```

However, following our three steps detailed in the first section, we can define our comparisons from the design matrix:

```{r}
# define the model matrix
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat
```

```{r}
# calculate coefficient vectors for each group
bloodA <- colMeans(mod_mat[dds$bloodtype == "bloodA", ])
bloodB <- colMeans(mod_mat[dds$bloodtype == "bloodB", ])
bloodO <- colMeans(mod_mat[dds$bloodtype == "bloodO", ])
```

And we can now define any contrasts we want:

```{r, fig.keep = "none"}
# obtain results for each pairwise contrast
res2_bloodA_bloodO <- results(dds, contrast = bloodA - bloodO)
res2_bloodB_bloodO <- results(dds, contrast = bloodB - bloodO)
res2_bloodA_bloodB <- results(dds, contrast = bloodA - bloodB)
# plot the results from the two approaches to check that they are identical
plot(res1_bloodA_bloodO$log2FoldChange, res2_bloodA_bloodO$log2FoldChange)
plot(res1_bloodB_bloodO$log2FoldChange, res2_bloodB_bloodO$log2FoldChange)
plot(res1_bloodA_bloodB$log2FoldChange, res2_bloodA_bloodB$log2FoldChange)
```

## A and B against O (slide 7)
With this approach, we could even define a more unusual contrast, for example to find genes that differ between A and B against and O samples:

```{r}
# define vector of coefficients for A_B samples
A_B <- colMeans(mod_mat[dds$bloodtype %in% c("bloodA", "bloodB"),])
# Our contrast of interest is
A_B - bloodO
```

Notice the contrast vector in this case assigns a "weight" of 0.5 to each of `bloodtypebloodA` and `bloodtypebloodB`. This is equivalent to saying that we want to consider the average of bloodA and bloodB expression. In fact, we could have also defined our contrast vector like this:

```{r}
# average of bloodA and bloodB minus bloodO
(bloodA + bloodB)/2 - bloodO
```

To obtain our results, we use the `results()` function as before:

```{r}
# get the results between A_B and bloodA
res2_AB <- results(dds, contrast = A_B - bloodO)
```


## Extra: why not define a new group in our design matrix? (slide 8)

For this last example (A_B vs bloodO), we may have considered creating a new variable in our column data:

```{r}
dds$A_B <- factor(dds$bloodtype %in% c("bloodA", "bloodB"))
colData(dds)
```

and then re-run DESeq with a new design:

```{r, message=FALSE}
design(dds) <- ~ 1 + A_B
dds <- DESeq(dds)
resultsNames(dds)
res1_A_B <- results(dds, contrast = list("A_B_TRUE_vs_FALSE"))
```

However, in this model the gene dispersion is estimated together for bloodA and bloodB samples as if they were replicates of each other, which may result in inflated/deflated estimates. 
Instead, our approach above estimates the error within each of those groups. 

To check the difference one could compare the two approaches visually:

```{r, eval=FALSE}
# compare the log-fold-changes between the two approaches
plot(res1_A_B$log2FoldChange, res2_A_B$log2FoldChange)
abline(0, 1, col = "brown", lwd = 2)
# compare the errors between the two approaches
plot(res1_A_B$lfcSE, res2_A_B$lfcSE)
abline(0, 1, col = "brown", lwd = 2)
```


# Two factors with interaction (slide 9)

```{r}
# simulate data
dds <- makeExampleDESeqDataSet(n = 1000, m = 12, betaSD = 2)
dds$bloodtype <- factor(rep(c("bloodO", "bloodA"), each = 6))
dds$bloodtype <- relevel(dds$bloodtype, "bloodO")
dds$condition <- factor(rep(c("treat", "control"), 6))
dds <- dds[, order(dds$bloodtype, dds$condition)]
colnames(dds) <- paste0("sample", 1:ncol(dds))
```

First let's look at our sample information:

```{r}
colData(dds)
```

This time we have two factors of interest, and we want to model both with an interaction (i.e. we assume that bloodA and bloodO samples may respond differently to treat/control). 
We define our design accordingly and fit the model:

```{r, message=FALSE}
design(dds) <- ~ 1 + bloodtype + condition + bloodtype:condition
dds <- DESeq(dds)
resultsNames(dds)
```

Because we have two factors and an interaction, the number of comparisons we can do is larger. 
Using our three-step approach from the model matrix, we do things exactly as we've been doing so far:

```{r}
# get the model matrix
mod_mat <- model.matrix(design(dds), colData(dds))
# Define coefficient vectors for each condition
bloodO_control <- colMeans(mod_mat[dds$bloodtype == "bloodO" & dds$condition == "control", ])
bloodO_treat <- colMeans(mod_mat[dds$bloodtype == "bloodO" & dds$condition == "treat", ])
bloodA_control <- colMeans(mod_mat[dds$bloodtype == "bloodA" & dds$condition == "control", ])
bloodA_treat <- colMeans(mod_mat[dds$bloodtype == "bloodA" & dds$condition == "treat", ])
```

We are now ready to define any contrast of interest from these vectors (for completeness we show the equivalent syntax using the coefficient's names from DESeq).

bloodA vs bloodO (in the control):

```{r}
res1 <- results(dds, contrast = bloodA_control - bloodO_control)
# or equivalently
res2 <- results(dds, contrast = list("bloodtype_bloodA_vs_bloodO"))
```

bloodA vs bloodO (in the treatment):

```{r}
res1 <- results(dds, contrast = bloodO_treat - bloodA_treat)
# or equivalently
res2 <- results(dds, contrast = list(c("bloodtype_bloodA_vs_bloodO",
                                       "bloodtypebloodA.conditiontreat")))
```

treat vs control (for bloodtypes O):

```{r}
res1 <- results(dds, contrast = bloodO_treat - bloodO_control)
# or equivalently
res2 <- results(dds, contrast = list(c("condition_treat_vs_control")))
```

treat vs control (for bloodtypes A):

```{r}
res1 <- results(dds, contrast = bloodA_treat - bloodA_control)
# or equivalently
res2 <- results(dds, contrast = list(c("condition_treat_vs_control", 
                                       "bloodtypebloodA.conditiontreat")))
```

Interaction between bloodtype and condition (i.e. do bloodAs and bloodOs respond differently to the treatment?):

```{r}
res1 <- results(dds, 
                contrast = (bloodA_treat - bloodA_control) - (bloodO_treat - bloodO_control))
# or equivalently
res2 <- results(dds, contrast = list("bloodtypebloodA.conditiontreat"))
```

In conclusion, although we can define these contrasts using DESeq coefficient names, it is somewhat more explicit (and perhaps intuitive?) what it is we're comparing using matrix-based contrasts. 


# Three factors, with nesting (slide 10)

```{r}
# simulate data
dds <- makeExampleDESeqDataSet(n = 1000, m = 24, betaSD = 2)
dds$bloodtype <- factor(rep(c("bloodA", "bloodO"), each = 12))
dds$bloodtype <- relevel(dds$bloodtype, "bloodO")
dds$patient <- factor(rep(LETTERS[1:4], each = 6))
dds$condition <- factor(rep(c("treat", "control"), 12))
dds <- dds[, order(dds$bloodtype, dds$patient, dds$condition)]
colnames(dds) <- paste0("sample", 1:ncol(dds))
```

First let's look at our sample information:

```{r}
colData(dds)
```

Now we have three factors, but patient is _nested_ within bloodtype (i.e. a patient is either bloodA or bloodO, it cannot be both). 
Therefore, bloodtype is a linear combination with patient (or, another way to think about it is that bloodtype is redundant with patient). 
Because of this, we will define our design without including "bloodtype", although later we can compare groups of patient of the same bloodtype with each other.

```{r, message=FALSE}
design(dds) <- ~ 1 + patient + condition + patient:condition
dds <- DESeq(dds)
resultsNames(dds)
```

Now it's harder to define contrasts between groups of patient of the same bloodtype using DESeq's coefficient names (although still possible). 
But using the model matrix approach, we do it in exactly the same way we have done so far!

Again, let's define our groups from the model matrix:

```{r}
# get the model matrix
mod_mat <- model.matrix(design(dds), colData(dds))
# define coefficient vectors for each group
bloodO_control <- colMeans(mod_mat[dds$bloodtype == "bloodO" & dds$condition == "control", ])
bloodA_control <- colMeans(mod_mat[dds$bloodtype == "bloodA" & dds$condition == "control", ])
bloodO_treat <- colMeans(mod_mat[dds$bloodtype == "bloodO" & dds$condition == "treat", ])
bloodA_treat <- colMeans(mod_mat[dds$bloodtype == "bloodA" & dds$condition == "treat", ])
```

It's worth looking at some of these vectors, to see that they are composed of weighted coefficients from different patient. 
For example, for "bloodO" patient, we have equal contribution from "patientC" and "patientD":

```{r}
bloodO_control
```

And so, when we define our contrasts, each patient will be correctly weighted:

```{r}
bloodO_treat - bloodO_control
```

We can set our contrasts in exactly the same way as we did in the previous section (for completeness, we also give the contrasts using DESeq's named coefficients). 

bloodA vs bloodO (in the control):

```{r, eval=FALSE}
res1_bloodA_bloodO_control <- results(dds, contrast = bloodA_control - bloodO_control)
# or equivalently
res2_bloodA_bloodO_control <- results(dds, 
                                 contrast = list(c("patient_B_vs_A"), # Blood type A
                                                 c("patient_C_vs_A", # Blood type O
                                                   "patient_D_vs_A"))) # Blood type O
```

bloodA vs bloodO (in the treat):

```{r}
res1_bloodO_bloodA_treat <- results(dds, contrast = bloodO_treat - bloodA_treat)
# or equivalently
res2_bloodO_bloodA_treat <- results(dds, 
                           contrast = list(c("patient_B_vs_A", # Blood type A
                                             "patientB.conditiontreat"), # Interaction of patient B with treatment
                                           c("patient_C_vs_A", # Blood type O
                                             "patient_D_vs_A", # Blood type O
                                             "patientC.conditiontreat", # Interaction of patient C with treatment
                                             "patientD.conditiontreat"))) # Interaction of patient B with treatment
```

And so on, for other contrasts of interest...

## Extra: imbalanced design

Let's take our previous example, but drop one of the samples from the data, so that we only have 2 replicates for it.

```{r, message=FALSE}
dds <- dds[, -1] # drop one of the patient C samples
dds <- DESeq(dds)
resultsNames(dds)
```

Define our model matrix and coefficient vectors:

```{r}
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat
# define coefficient vectors for each group
bloodO_control <- colMeans(mod_mat[dds$bloodtype == "bloodO" & dds$condition == "control", ])
bloodA_control <- colMeans(mod_mat[dds$bloodtype == "bloodA" & dds$condition == "control", ])
bloodO_treat <- colMeans(mod_mat[dds$bloodtype == "bloodO" & dds$condition == "treat", ])
bloodA_treat <- colMeans(mod_mat[dds$bloodtype == "bloodA" & dds$condition == "treat", ])
```

Now let's check what happens to the bloodO_control group:

```{r}
bloodO_control
```

Notice that whereas before "patientC" and "patientD" had each a weight of 0.5, now they have different weights. 
That's because for patientC there's only 2 replicates.
So, we have a total of 5 bloodtype O individuals in the control (2 from patient C and 3 from D). 
Therefore, when we calculate the average coefficients for bloodOs, we need to do it as 0.4 x patientC + 0.6 x patientD. 

The nice thing about this approach is that we do not need to worry about any of this, the weights come from our `colMeans()` call automatically. 
And now, any contrasts that we make will take these weights into account:

```{r}
# bloodA vs bloodO (in the control)
bloodA_control - bloodO_control
# interaction
(bloodA_treat - bloodA_control) - (bloodO_treat - bloodO_control)
```

