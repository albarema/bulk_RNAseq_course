---
title: "Bulk RNAseq Exploratory Analysis"
author: "Jose Alejandro Romero Herrera"
date: '`r Sys.Date()`'
knit: (function(inputFile, encoding) { 
      rmarkdown::render(inputFile,
                        encoding=encoding,
                        output_format='all',
                        output_dir='./reports/')})
output:
  # To create PDF report, uncomment below
  #pdf_document:
  #  toc: yes
  # html_document:
  #   number_sections: yes
  #   theme: yeti
  #   toc: yes
  #   toc_float: yes
  #   df_print: paged
  #   dev: png
  md_document
---

```{r knitr, include = FALSE}
DOCNAME = knitr::current_input()
knitr::opts_chunk$set(autodep        = TRUE,
                      cache          = FALSE,
                      cache.path     = paste0("cache/", DOCNAME, "/"),
                      cache.comments = TRUE,
                      echo           = TRUE,
                      error          = FALSE,
                      fig.align      = "center",
                      fig.path       = paste0("./figures/", DOCNAME, "/"),
                      fig.width      = 10,
                      fig.height     = 8,
                      message        = FALSE,
                      warning        = FALSE)
```

# Exploratory analysis
After running the `DESeq()` function, we can start our RNAseq analysis by exploring the relationships between our samples. In principle, all replicates for a specific condition should be similar to each other after normalization. Should this not be the case, one might need to remove outlier replicates. This is one of the reasons why RNAseq experiments need at least 3 replicates per condition. 

## Data transformations
For visualization and clustering (exploratory analyses) â€“ it might be useful to work with transformed versions of the count data. There are two main methods used for this purpose: variance stabilizing transformations (**VST**), and the regularized logarithm or **rlog**. Both transformations produce transformed data on the log2 scale which has been normalized with respect to library size or other normalization factors.

```{r}
vsd <- vst(dds) #Variance Stabilizing Transformation, vst is faster with larger number of samples
rld <- rlog(dds) #Regularized 
```

## Samples comparisons 
We can do some sanity checks of the samples. We can see how they correlate to each other in a heatmap or see their Principal Components with a PCA plot.

### Heatmap of the sample-to-sample distances
This plot shows how far away are each sample from each other. The darker the blue, the closer they are.
```{r, sample_distances_heatmap}
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$condition, vsd$type, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```

### Principal component plot of the samples
PCA plot using the first two components
```{r PCA_plot}
pcaData <- plotPCA(vsd, intgroup=c("condition", "type"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=condition, shape=type)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed() + theme_bw()
```
### Glimma plots
Interactive visualizations of the DESeq results using the **Glimma** package, which provides excellent options for MA, Volcano and dimensionality reduction (like a PCA) plots. Use the *groups* argument to provide the condition or factor of your experiment. Unfortunately, the interactive plots created here are not fully compatible when knitting this document. Feel free to explore them using this [link](./mds-plot.html)!

```{r}
#glimmaMDS(dds, groups = dds$condition)
```

Save your interactive plots using the **htmlwidgets** packages, specifically, the `saveWidget()` 
```{r}
#htmlwidgets::saveWidget(glimmaMDS(dds, groups = dds$condition), "mds-plot.html")
```

## Plot counts
It can be useful to examine the counts of reads for a single gene across the conditions. A simple function for making this plot is plotCounts, which normalizes counts by the estimated size factors (or normalization factors if these were used) and adds a pseudocount of 1/2 to allow for log scale plotting. The counts are grouped by the variables in *intgroup* argument, where more than one variable can be specified. You can select the gene to plot by its name or by numeric index.

```{r plot_counts_example, fig.height=5, fig.width=5}
d <- plotCounts(dds, gene= 1, intgroup="condition", 
                returnData=TRUE)
ggplot(d, aes(x=condition, y=count, color = condition)) + 
  geom_point(position=position_jitter(w=0.1,h=0)) + 
  scale_y_log10(breaks=c(25,100,400)) + theme_bw()
```

# Session info
Finally, we create a `session_info()` table that will allow anyone to check what versions of R and packages are we using for reproducibility purposes.

```{r session-info}
devtools::session_info()
```